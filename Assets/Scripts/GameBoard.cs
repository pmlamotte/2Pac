//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18052
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System;
using System.Collections.Generic;
namespace AssemblyCSharp
{
	public class GameBoardData
	{
		public static IntVector2[] directions = new IntVector2[]{new IntVector2(1,0), new IntVector2(0,1), new IntVector2(-1,0), new IntVector2(0,-1)};
		private bool[,] board;
		public IntVector2 ghostSpawn {get; private set;}

		public int Height {get; private set;}
		public int Width {get; private set; }


		public GameBoard (string[] sboard)
		{
			bool[,] board = new bool[sboard.Length, sboard[0].Length];
			for ( int i = 0; i < board.GetLength(0); i++ )
			{
				for (int j = 0; j < board.GetLength(1); j++ )
				{
					if ( sboard[i][j] == '1' )
					{
						board[i,j] = true;
					}
					else 
					{
						if ( sboard[i][j] == 'G' )
						{
							ghostSpawn = new IntVector2( j, i );
						}
					}
				}
			}

			this.board = board;
			this.Height = board.GetLength(0);
			this.Width = board.GetLength(1);
		}

		public bool isOpen( IntVector2 v )
		{
			return isOpen( v.x, v.y );
		}

		public bool isOpen( int x, int y )
		{
			if ( x < 0 ) return false;
			if ( y < 0 ) return false;
			if ( x >= board.GetLength(1) ) return false;
			if ( y >= board.GetLength(0) ) return false;
			return !board[y,x];
		}


		public Vector3 convertToRenderPos( BoardLocation b )
		{
			float x = .5f + b.location.x + ((float)b.offset.x) / BoardLocation.cellRadius;
			float y = .5f + b.location.y + ((float)b.offset.y) / BoardLocation.cellRadius;
			return new Vector3( x, y, 0 );
		}


		public void insertGhost( GameObject g )
		{
			GhostMovement gMove = (GhostMovement) g.GetComponent( "GhostMovement" );
			gMove.boardLocation = new BoardLocation( ghostSpawn, new IntVector2( 0,0 ) );
		}


		public IntVector2 moveTowards( BoardLocation pos, BoardLocation target, int maxSpeed )
		{
			pos = pos.Clone();
			target = target.Clone();

			// get grid positions
			IntVector2 thisPos = pos.location;
			IntVector2 targetPos = target.location;

			HashSet<IntVector2> visited = new HashSet<IntVector2>();
			Dictionary<IntVector2, IntVector2> previous = new Dictionary<IntVector2, IntVector2>();

			LinkedList<IntVector2> queue = new LinkedList<IntVector2>();
			queue.AddLast( thisPos );

			while ( queue.Count > 0 )
			{
				IntVector2 p = queue.First.Value;
				queue.RemoveFirst();
				if ( p.Equals( targetPos ) ) break;
				foreach ( IntVector2 dir in directions )
				{
					IntVector2 posToVisit = dir + p;
					if ( !isOpen( posToVisit ) ) continue;
					if ( visited.Contains( posToVisit ) ) continue;
					visited.Add( posToVisit );
					previous[posToVisit] = p;
					queue.AddLast( posToVisit );
				}
			}

			LinkedList<IntVector2> path = new LinkedList<IntVector2>();
			IntVector2 curr = targetPos;
			while ( !curr.Equals( thisPos ) )
			{
				path.AddFirst( curr );
				curr = previous[curr];
			}

			// there is a path and its length is not 0
			if ( path.Count > 0 )
			{
				// head in the direction of first
				IntVector2 direction = new IntVector2( path.First.Value.x, path.First.Value.y ) - new IntVector2( thisPos.x, thisPos.y );
				direction.Normalize();
				direction *= maxSpeed;

				// direction will be orthogonal
				BoardLocation afterMove = tryMove( pos, direction );
				if ( BoardLocation.SqrDistance( afterMove, pos ) > maxSpeed * maxSpeed / 4 )
				{
					// move there
					return direction;
				}
			}
			//otherwise move towards center of current square
			IntVector2 cellPos = pos.offset;
			cellPos.Normalize();
			cellPos *= -maxSpeed;
			return cellPos;

		}

		public BoardLocation tryMove( BoardLocation pos, IntVector2 vel )
		{
			// the tile coordinates
			int x = pos.location.x;
			int y = pos.location.y;

			// the position within the tile, center is (0,0), +y is up
			int cellPosX = pos.offset.x;
			int cellPosY = pos.offset.y;

			cellPosX += vel.x;
			cellPosY += vel.y;

			// array representing whether there is a path to the right, up, left, and down respectively
			bool[] roads = new bool[4]{ isOpen(x + 1,y), 
				                        isOpen(x, y + 1), 
				                        isOpen(x - 1,y), 
				                        isOpen(x, y - 1)};

			// force position to an axis when there is not a road in the direction the position is off
			if ( cellPosX > 0 && !roads[0] ) cellPosX = 0;
			if ( cellPosX < 0 && !roads[2] ) cellPosX = 0;
			if ( cellPosY > 0 && !roads[1] ) cellPosY = 0;
			if ( cellPosY < 0 && !roads[3] ) cellPosY = 0;

			// force to the closer axis
			if ( Math.Abs( cellPosX ) > Math.Abs( cellPosY ) ) cellPosY = 0;
			else cellPosX = 0;

			// translate back to world coords and return
			return new BoardLocation( new IntVector2( x, y ), new IntVector2( cellPosX, cellPosY ));

		}


	}
}

